[{"title":"jqweui loading 如何显示","date":"2017-11-30T05:03:09.000Z","path":"2017/11/30/jqweui_toast/","text":"首先吐槽一下 jqweui的官方手册，有的地方确实不是太完善。不过现在做小程序的应该用官方的weui了。 toast 在jqweui 的手册中，只有下面几个方法（http://jqweui.com/components#toast ）。 12345$.toast(\"取消操作\", \"cancel\");$.toast(\"禁止操作\", \"forbidden\");$.toast(\"纯文本\", \"text\");// 第二个参数可以是时间，单位毫秒$.toast(\"消息\", 20000); 但是右边的正在加载样式，手册中怎么也找不到。百度了一遍，解决方案几乎千篇一律的是自己用jqweui的样式自己封装。无赖只能F12 找到对应的按钮后，发现官方有现成的方法可以调用。 展示正在加载中页面1$.showLoading(\"开门中...\"); 关闭正在加载中页面 1$.hideLoading(); ok，完美解决。","tags":[{"name":"jqweui","slug":"jqweui","permalink":"http://www.niuhead.com/tags/jqweui/"},{"name":"weui'","slug":"weui","permalink":"http://www.niuhead.com/tags/weui/"}]},{"title":"Ubuntu17.04+github+hexo 搭建博客","date":"2017-11-11T07:22:58.000Z","path":"2017/11/11/Ubuntu17.04+github+hexo 搭建博客/","text":"第一步: 首先安装nodejs,这个是hexo运行的基础环境,安装很简便:1$ sudo apt-get install nodejs 第二步 安装npm,这个也很简单,这是是node.js的包管理器,跟apt,pip等差不多的东东, 直接1$ sudo apt-get install npm 第三步接下来安装hexo或者hexo-cli,后者安装出现问题,前者没有问题,暂时还不知道原因.所以我安装的是hexo,如果你使用sudo npm install hexo -g 或者 sudo npm install hexo-cli -g,是不会成功的,最起码我是这样的。正确的方法如下:1$ sudo npm install --unsafe-perm --verbose -g hexo 第四步修改以下hexo所在路径的文件1$ sudo vi /usr/local/lib/node_modules/hexo/bin/hexo 把#!/usr/bin/env node修改为!/usr/bin/env nodejs即可 123#!/usr/bin/env nodejs&apos;use strict&apos;;require(&apos;hexo-cli&apos;)(); 然后输入hexo 看是否安装成功 第五步创建项目： 12345$ mkdir blog$ cd blog$ hexo init$ hexo g # 生成$ hexo s # 启动服务 然后输入127.0.0.1：4000 就可以预览蓝 第六步上传到github 首先在github 建造一个 youname(自己的github名字).github.io 在项目文件下安装插件 1npm install hexo-deployer-git --save 在__config.yml中加入 1234deploy: type: git repository: git@github.com:youname/youmane.github.io.git branch: master 然后进入blog 文件 12$ hexo g$ hexo d 就可以上传到github了。然后youname.github.io 就可以访问到blog蓝","tags":[{"name":"github","slug":"github","permalink":"http://www.niuhead.com/tags/github/"},{"name":"hexo","slug":"hexo","permalink":"http://www.niuhead.com/tags/hexo/"}]},{"title":"《高性能MySQL》笔记 - MySQL 锁的基本类型","date":"2017-10-06T07:53:58.000Z","path":"2017/10/06/mysql-lock/","text":"MySQL 主要在两个层面上实现并发控制：服务器层和存储引擎层。当读写有冲突的时候，一般对于MySQL来说，是进行锁表操作的。 读写锁读锁：读锁是共享的，多个用户同一时刻读取同一资源，他们之前互不影响。 写锁：写锁则是排他的，也就是说一个写锁会阻塞其他的写锁和读锁，这是出于安全策略的考虑，只有这样，才能确保在给定的时间里，只有一个用户能执行写入，并防止其他用户读取正在写入的同一资源。 锁粒度一种提高共享资源的并发性的方式就是让锁定的对象更有选择性。尽量只锁定需要修改的部分数据，而不是所有资源。更加理想的方式是，只对会修改的数据片进行精确的锁定。任何时候，在给定的资源上，锁定的数据量越少，则系统的并发程度越高，只要相互之间不发生冲突即可。 但是，所有的锁都是需要消耗资源的。锁的各种操作，包括获得锁，检查锁是否已经解除，释放锁等，都会增加系统的开销。 这里我们可以意识到：所谓的锁策略，是在锁的开销和数据的安全之间寻求平衡，这种平衡会影响到性能。 表锁表锁是MySQL中的基本策略，并且是开销最小的策略。当一个用户在对表进行操作(CUD)前，需要先获得写锁，这会阻塞其他用户对该表的所有操作。只有没有写锁时，其他读取用户才能获得读锁，读锁之间互不阻塞。 行锁行级锁可以最大程度的支持并发处理(同时也带来了最大的锁开销)。","tags":[{"name":"MySQl","slug":"MySQl","permalink":"http://www.niuhead.com/tags/MySQl/"},{"name":"高并发","slug":"高并发","permalink":"http://www.niuhead.com/tags/高并发/"},{"name":"数据库锁","slug":"数据库锁","permalink":"http://www.niuhead.com/tags/数据库锁/"}]},{"title":"写在开头","date":"2017-10-05T07:22:28.000Z","path":"2017/10/05/hello-world/","text":"嗯,作为一个coder,早就有打算做一个博客的的想法，今天用github+hexo搭建这个blog，基本上还算顺利！以后的日子里，会将工作中遇到的一些问题解决的方案记录在这里。由于一些客观原因，有的解决方案会有些缺陷，欢迎PR！ 嗯，今天是blog可以访问的第一天，也算是自己的一个小小的成就。目前的想法是blog的内容主要有 PHP，MySQL，Linux(简单的运维知识)，以及会有一些python的东西。","tags":[]},{"title":"如何优雅的使用接口","date":"2017-06-02T07:22:28.000Z","path":"2017/06/02/interface/","text":"嗯，6.1刚过完，我们不在是宝宝了，来吧，撸一篇接口的文章(interface). 在编程的过程中我们应该学会如何使用接口来给变我们的生活，极大的提升自我能力。接口不是新特性，但是非常重要，下面我们来撸个接口的小例子。 虚构一个DocumentStore的类，这个类负责从不同的资源收集文本。可以从远程url读取html，也可以读取资源，也可以收集终端命令输出。 定义DocumentStore类 1234567891011121314class DocumentStore&#123; protected $data = []; public function addDocument(Documenttable $document)&#123; $key = $document-&gt;getId(); $value = $document-&gt;getContent(); $this-&gt;data[key] = $value; &#125; public function getDocuments()&#123; return $this-&gt;data; &#125; &#125; 既然addDocument()方法的参数只能是Documenttable的类的实例，这样定义DocumentStore的类怎么行呢? 其实Documenttable不是类，是接口； 定义Documenttable 123456interface Documenttable&#123; public function getId(); public function getContent(); &#125; 这个接口定义表名，实现Documenttable接口的任何对象都必须提供一个公开的getId()方法和一个公开的getContent()方法。 可是这么做有什么用呢？这么做的好处就是，我们可以分开定义获取稳定的类，而且能使用十分不同的方法。下面是一种实现方式，这种方式使用curl从远程url获取html。 定义HtmlDocument类 123456789101112131415161718192021222324class HtmlDocument implements Documenttable&#123; protected $url; public function __construct($url) &#123; $this-&gt;url = $url; &#125; public function getId()&#123; return $this-&gt;url; &#125; public function getContent()&#123; $ch = curl_init(); curl_setopt($ch,CURLOPT_URL,$this-&gt;url); curl_setopt($ch,CURLOPT_RETURNTRANSFER,1); curl_setopt($ch,CURLOPT_CONNECTTIMEOUT,3); curl_setopt($ch,CURLOPT_FOLLOWLOCATION,1); curl_setopt($ch,CURLOPT_MAXREDIRS,3); curl_close($ch); return $thml; &#125;&#125; 下面一个方法是获取流资源。 123456789101112131415161718192021222324class StreamDocument implements Documenttable&#123; protected $resource; protected $buffer; public function __construct($resource,$buffer = 4096) &#123; $this-&gt;resource=$resource; $this-&gt;buffer=$buffer; &#125; public function getId()&#123; return 'resource-' .(int)$this-&gt;resource; &#125; public function getContent()&#123; $streamContent = ''; rewind($this-&gt;resource); while (feof($this-&gt;resource) === false)&#123; $streamContent .= fread($this-&gt;resource,$this-&gt;buffer); &#125; return $streamContent; &#125;&#125; 下面一个类是获取终端命令行的执行结果。 12345678910111213141516class CommandOutDocument implements Documenttable&#123; protected $command; public function __construct($command) &#123; $this-&gt;command=$command; &#125; public function getId()&#123; return $this-&gt;command; &#125; public function getContent()&#123; return shell_exec($this-&gt;command); &#125;&#125; 下面我们来演示一下借助上面的三个类来实现DocumentStore类。 123456789101112131415161718192021$documentStore = new DocumentStore();//添加html文档$htmlDoc = new HtmlDocument('https:// www.i360.me');$documentStore-&gt;addDocument($htmlDoc);//添加流文档$streamDOC = new StreamDocument(fopen('stream.txt','rb'));$documentStore-&gt;addDocument($streamDOC);//添加终端命令文档$cmdDoc = new CommandOutDocument('cat /etc/hosts');$documentStore-&gt;addDocument($command);print_r($documentStore-&gt;getDocuments());die; 这里HtmlDocument，StreamDocument，CommandOutDocument这三个类没有任何共同点，只是实现了同一个接口。","tags":[{"name":"接口","slug":"接口","permalink":"http://www.niuhead.com/tags/接口/"},{"name":"设计模式","slug":"设计模式","permalink":"http://www.niuhead.com/tags/设计模式/"}]}]